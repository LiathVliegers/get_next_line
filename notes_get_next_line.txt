




File Descriptor (fd) return values:
-1 	= NONEXISTANT.
0 	= STDIN				this is where it gets its input.
1 	= STDOUT			this is where it sends it's output.
2 	= STDERR			this is where it reports errors.
3 	= 					this can be the next file, if you create another one it can return 4, and the next one will be 5.

if the program returns -1 the file in nonexistent.
0, 1 and 2 are all connected to the terminal. 


EVERYTHING is a file. The terminal is a file, a file is a file enz.
the file descriptor is a series of numbers linked to a specific file that your operating system is handling when a process is launched.





OPEN FUNCTION:

int open(const char *pathname, int flags);

	The open() function opens a file for reading or writing. 
	This function opens the file that is specified in the pathname input argument. 
	This input must specify the absolute or relative path and the name of the file in string format or a pointer to it.
	
	The flags input argument specifies the attributes that the file must have. 
	The following is a list of the flags that this input argument accepts, and a brief description of the attribute that each one sets:

Flag 		Description
O_RDONLY 	Open file for reading only.
O_WRONLY 	Open file for writing only.
O_RDWR 		Open file for reading and writing.
O_CREAT 	Creates a file in the path and name specified in pathname argument.
O_ APPEND 	Opens the file and places the cursor at the end of the contents.
O_ASYNC 	Enable input and output control by signal.
O_CLOEXEC 	Enable close-on-exec mode on the open file.
O_NONBLOCK 	Disables blocking of the file opened.
O_TMPFILE 	Create an unnamed temporary file at the specified path.

In cases where more than one flag is used, a logical “OR” operation must be performed between them.


Example:
int main()
{
	int fd;

	fd = open("file.txt", O_RDONLY | O_CREAT);

	printf("fd of the file is: %d\n", fd);

	write(1, "hello", 5);		"hello" will be displayed in the terminal
	write(fd, "hello", 5);		"hello" will be displayed in file.txt file
}



READ FUNCTION:

read returns the number of bytes read, -1 for errors and 0 for end of file

int read(int fileDescriptor, void *buffer, size_t bytesToRead);

It takes in three arguments which are described below:
    1. fileDescriptor: We need to provide the function with an integer file descriptor for the opened file, which the open() function returns when opening a file.
    2. buffer: This pointer points to a buffer where data that is read will be stored.
    3. bytesToRead: Here, we provide an unsigned integer variable that specifies the maximum number of bytes we want to read from the file.

EXAMPLE: 
read(3, buf, 10);
"Read from the fd 3 into the buffer, 10 bytes (or in this case chars) per call to the function"
when i recall the function, i get THE NEXT 10 bytes(chars).













WORKING VERSION OF GET NEXT LINE:
char	*get_next_line(int fd)
{
	char buffer[1024];
	int bytes_read;
	char *next_line;
	int len;
	static int start = 0;
	
	len = 0;
	bytes_read = read(fd, buffer, sizeof(buffer));

	printf("%d bytes read!\n", bytes_read);
	
	while(buffer[start + len] != '\n')
		len++;
	
	next_line = ft_substr(buffer, start, len);
	start = start + len + 1;

	return(next_line);
}

int	main(void)
{
	int fd;

	fd = open("textfile.txt", O_RDONLY);
	printf("The fist line of the file = %s\n", get_next_line(fd));
	printf("The seccond line of the file = %s\n", get_next_line(fd));
	printf("The third line of the file = %s\n", get_next_line(fd));
	printf("The fourth line of the file = %s\n", get_next_line(fd));
	printf("The fifth line of the file = %s\n", get_next_line(fd));
	printf("The sixth line of the file = %s\n", get_next_line(fd));
	printf("The seventh line of the file = %s\n", get_next_line(fd));
	
	return (0);
}

TEXTFILE:
Halloooooooo dit is de eerste regel JOEPIIIEE!!!!!!!!!!!!!
Dit is de tweede regel.
Dit is de derde regel.
Dit is de vierde regel. Hierna komen twee new lines, wat gaan we daarmee doen?


Dit is de vijfde (of eigenlijk zevende) regel.

OUTPUT:
234 bytes read!
The fist line of the file = Halloooooooo dit is de eerste regel JOEPIIIEE!!!!!!!!!!!!!
0 bytes read!
The seccond line of the file = Dit is de tweede regel.
0 bytes read!
The third line of the file = Dit is de derde regel.
0 bytes read!
The fourth line of the file = Dit is de vierde regel. Hierna komen twee new lines, wat gaan we daarmee doen?
0 bytes read!
The fifth line of the file = 
0 bytes read!
The sixth line of the file = 
0 bytes read!
The seventh line of the file = Dit is de vijfde (of eigenlijk zevende) regel.


--------------------------------------------------------------------------------



GET NEXT LINE!

MAIN
- open the file or files in main
- call ft_get next line for the fd you want
GET_NEXT_LINE(fd)
- in the function ft_get_nextLine we declare a static char* substrings[MAX_FD], we also declare a small char *buffer to store the BUFFER_SIZE abount of bites in, and a char *next_line that we were meant to get
- if de fd is less than 0 or BUFFER_SIZE is 0 or less, we return (NULL)
- we malloc BUFFER_SIZE + 1 for buffer and protect it ofcourse
- then we initialize next_line to the return value of the function ft_readline and pass it the fd, the buffer and substrings[fd], this is where the magic happens!
- we don't need buffer anymore so we can free it, and set it to NULL
- now we need to put the remainder of buffer (after the \n) in substrings[fd]
READLINE(the fd, the buffer, substrings[fd])
- initialize int bytes_read and a char *next_line and a char *temp
- bytes_read = 1
- in a while loop: while bytes_read != 0, then we do this:
- bytes_read = read(file bla bla)
- if (ft_strchr(buf, '\n'))
	{
		
	}
	else
	{
- 		temp = next_line
- 		next_line = strjoin(temp, buffer)
	}
- 
- 
- 
- 









Get next line


/* 
*	GET_NEXT_LINE
*	-------------
*	DESCRIPTION
*	This function takes an opened file descriptor and returns its next line.
*	This function has undefined behavior when reading from a binary file.
*	PARAMETERS
*	#1. A file descriptor 
*	RETURN VALUES
*	If successful, get_next_line returns a string with the full line ending in
*	a line break (`\n`) when there is one. 
*	If an error occurs, or there's nothing more to read, it returns NULL.
*	----------------------------------------------------------------------------
*	AUXILIARY FUNCTIONS
*	-------------------
*	READ_TO_LEFT_STR
*	-----------------
*	DESCRIPTION
*	Takes the opened file descriptor and saves on a "buff" variable what readed
*	from it. Then joins it to the cumulative static variable for the persistence
*	of the information.
*	PARAMETERS
*	#1. A file descriptor.
*	#2. The pointer to the cumulative static variable from previous runs of
*	get_next_line.
*	RETURN VALUES
*	The new static variable value with buffer joined for the persistence of the info,
*	or NULL if error.
*/

/*
*	---------
*	GET_LINE
*	---------
*	Extracts the line (ending in either line break and `\0` or only `\0` in EOF)
*	from static variable.
*	PARAMETERS
*	#1. The pointer to the cumulative static variable from previous runs of get_next_line.
*	RETURN VALUES
*	The string with the full line ending in a line break (`\n`) + (`\0`).
*	-------------
*	NEW_LEFT_STR
*	-------------
*	Stores in the cumulative static variable the new updated variable with whatever
*	is left from the original, minus the line extracted.
*	PARAMETERS
*	#1. The pointer to the cumulative static variable from previous runs of get_next_line.
*	RETURN VALUES
*	The new updated string with whatever is left from the original static, minus the
*	line extracted.
*/

#include "get_next_line.h"
#include "get_next_line_bonus.h"
#include <unistd.h>
//#include <stdio.h>
//#include <fcntl.h>

size_t	ft_strlen(char *s)
{
	size_t	i;

	i = 0;
	if (!s)
		return (0);
	while (s[i] != '\0')
		i++;
	return (i);
}

char	*ft_strchr(char *s, int c)
{
	int	i;

	i = 0;
	if (!s)
		return (0);
	if (c == '\0')
		return ((char *)&s[ft_strlen(s)]);
	while (s[i] != '\0')
	{
		if (s[i] == (char) c)
			return ((char *)&s[i]);
		i++;
	}
	return (0);
}

char	*ft_strjoin(char *left_str, char *buff)
{
	size_t	i;
	size_t	j;
	char	*str;

	if (!left_str)
	{
		left_str = (char *)malloc(1 * sizeof(char));
		left_str[0] = '\0';
	}
	if (!left_str || !buff)
		return (NULL);
	str = malloc(sizeof(char) * ((ft_strlen(left_str) + ft_strlen(buff)) + 1));
	if (str == NULL)
		return (NULL);
	i = -1;
	j = 0;
	if (left_str)
		while (left_str[++i] != '\0')
			str[i] = left_str[i];
	while (buff[j] != '\0')
		str[i++] = buff[j++];
	str[ft_strlen(left_str) + ft_strlen(buff)] = '\0';
	free(left_str);
	return (str);
}

char	*ft_get_line(char *left_str)
{
	int		i;
	char	*str;

	i = 0;
	if (!left_str[i])
		return (NULL);
	while (left_str[i] && left_str[i] != '\n')
		i++;
	str = (char *)malloc(sizeof(char) * (i + 2));
	if (!str)
		return (NULL);
	i = 0;
	while (left_str[i] && left_str[i] != '\n')
	{
		str[i] = left_str[i];
		i++;
	}
	if (left_str[i] == '\n')
	{
		str[i] = left_str[i];
		i++;
	}
	str[i] = '\0';
	return (str);
}

char	*ft_new_left_str(char *left_str)
{
	int		i;
	int		j;
	char	*str;

	i = 0;
	while (left_str[i] && left_str[i] != '\n')
		i++;
	if (!left_str[i])
	{
		free(left_str);
		return (NULL);
	}
	str = (char *)malloc(sizeof(char) * (ft_strlen(left_str) - i + 1));
	if (!str)
		return (NULL);
	i++;
	j = 0;
	while (left_str[i])
		str[j++] = left_str[i++];
	str[j] = '\0';
	free(left_str);
	return (str);
}

char	*ft_read_to_left_str(int fd, char *left_str)
{
	char	*buff;
	int		rd_bytes;

	buff = malloc((BUFFER_SIZE + 1) * sizeof(char));
	if (!buff)
		return (NULL);
	rd_bytes = 1;
	while (!ft_strchr(left_str, '\n') && rd_bytes != 0)
	{
		rd_bytes = read(fd, buff, BUFFER_SIZE);
		if (rd_bytes == -1)
		{
			free(buff);
			return (NULL);
		}
		buff[rd_bytes] = '\0';
		left_str = ft_strjoin(left_str, buff);
	}
	free(buff);
	return (left_str);
}

char	*get_next_line(int fd)
{
	char		*line;
	static char	*left_str[4096];

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (0);
	left_str[fd] = ft_read_to_left_str(fd, left_str[fd]);
	if (!left_str[fd])
		return (NULL);
	line = ft_get_line(left_str[fd]);
	left_str[fd] = ft_new_left_str(left_str[fd]);
	return (line);
}

/*int	main(void)
{
	char	*line;
	int		i;
	int		fd1;
	int		fd2;
	int		fd3;

	fd1 = open("tests/test.txt", O_RDONLY);
	fd2 = open("tests/test2.txt", O_RDONLY);
	fd3 = open("tests/test3.txt", O_RDONLY);
	i = 1;
	while (i < 7)
	{
		line = get_next_line(fd1);
		printf("line [%02d]: %s", i, line);
		free(line);
		line = get_next_line(fd2);
		printf("line [%02d]: %s", i, line);
		free(line);
		line = get_next_line(fd3);
		printf("line [%02d]: %s", i, line);
		free(line);
		i++;
	}
	close(fd1);
	close(fd2);
	close(fd3);
	return (0);
}*/


