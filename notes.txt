




File Descriptor (fd) return values:
-1 	= NONEXISTANT.
0 	= STDIN				this is where it gets its input.
1 	= STDOUT			this is where it sends it's output.
2 	= STDERR			this is where it reports errors.
3 	= 					this can be the next file, if you create another one it can return 4, and the next one will be 5.

if the program returns -1 the file in nonexistent.
0, 1 and 2 are all connected to the terminal. 


EVERYTHING is a file. The terminal is a file, a file is a file enz.
the file descriptor is a series of numbers linked to a specific file that your operating system is handling when a process is launched.





OPEN FUNCTION:

int open(const char *pathname, int flags);

	The open() function opens a file for reading or writing. 
	This function opens the file that is specified in the pathname input argument. 
	This input must specify the absolute or relative path and the name of the file in string format or a pointer to it.
	
	The flags input argument specifies the attributes that the file must have. 
	The following is a list of the flags that this input argument accepts, and a brief description of the attribute that each one sets:

Flag 		Description
O_RDONLY 	Open file for reading only.
O_WRONLY 	Open file for writing only.
O_RDWR 		Open file for reading and writing.
O_CREAT 	Creates a file in the path and name specified in pathname argument.
O_ APPEND 	Opens the file and places the cursor at the end of the contents.
O_ASYNC 	Enable input and output control by signal.
O_CLOEXEC 	Enable close-on-exec mode on the open file.
O_NONBLOCK 	Disables blocking of the file opened.
O_TMPFILE 	Create an unnamed temporary file at the specified path.

In cases where more than one flag is used, a logical “OR” operation must be performed between them.


Example:
int main()
{
	int fd;

	fd = open("file.txt", O_RDONLY | O_CREAT);

	printf("fd of the file is: %d\n", fd);

	write(1, "hello", 5);		"hello" will be displayed in the terminal
	write(fd, "hello", 5);		"hello" will be displayed in file.txt file
}



READ FUNCTION:

int read(int fileDescriptor, void *buffer, size_t bytesToRead);

It takes in three arguments which are described below:
    1. fileDescriptor: We need to provide the function with an integer file descriptor for the opened file, which the open() function returns when opening a file.
    2. buffer: This pointer points to a buffer where data that is read will be stored.
    3. bytesToRead: Here, we provide an unsigned integer variable that specifies the maximum number of bytes we want to read from the file.

EXAMPLE: 
read(3, buf, 10);
"Read from the fd 3 into the buffer, 10 bytes (or in this case chars) per call to the function"
when i recall the function, i get THE NEXT 10 bytes(chars).













WORKING VERSION OF GET NEXT LINE:
char	*get_next_line(int fd)
{
	char buffer[1024];
	int bytes_read;
	char *next_line;
	int len;
	static int start = 0;
	
	len = 0;
	bytes_read = read(fd, buffer, sizeof(buffer));

	printf("%d bytes read!\n", bytes_read);
	
	while(buffer[start + len] != '\n')
		len++;
	
	next_line = ft_substr(buffer, start, len);
	start = start + len + 1;

	return(next_line);
}

int	main(void)
{
	int fd;

	fd = open("textfile.txt", O_RDONLY);
	printf("The fist line of the file = %s\n", get_next_line(fd));
	printf("The seccond line of the file = %s\n", get_next_line(fd));
	printf("The third line of the file = %s\n", get_next_line(fd));
	printf("The fourth line of the file = %s\n", get_next_line(fd));
	printf("The fifth line of the file = %s\n", get_next_line(fd));
	printf("The sixth line of the file = %s\n", get_next_line(fd));
	printf("The seventh line of the file = %s\n", get_next_line(fd));
	
	return (0);
}

TEXTFILE:
Halloooooooo dit is de eerste regel JOEPIIIEE!!!!!!!!!!!!!
Dit is de tweede regel.
Dit is de derde regel.
Dit is de vierde regel. Hierna komen twee new lines, wat gaan we daarmee doen?


Dit is de vijfde (of eigenlijk zevende) regel.

OUTPUT:
234 bytes read!
The fist line of the file = Halloooooooo dit is de eerste regel JOEPIIIEE!!!!!!!!!!!!!
0 bytes read!
The seccond line of the file = Dit is de tweede regel.
0 bytes read!
The third line of the file = Dit is de derde regel.
0 bytes read!
The fourth line of the file = Dit is de vierde regel. Hierna komen twee new lines, wat gaan we daarmee doen?
0 bytes read!
The fifth line of the file = 
0 bytes read!
The sixth line of the file = 
0 bytes read!
The seventh line of the file = Dit is de vijfde (of eigenlijk zevende) regel.


--------------------------------------------------------------------------------



GET NEXT LINE!

MAIN
- open the file or files in main
- call ft_get next line for the fd you want
GET_NEXT_LINE
- in the function ft_get_nextLine we declare a static char* substrings[MAX_FD], we also declare a small char *buffer to store the BUFFER_SIZE abount of bites in, and a char *next_line that we were meant to get
- if de fd is less than 0 or BUFFER_SIZE is 0 or less, we return (NULL)
- we malloc BUFFER_SIZE + 1 for buffer and protect it ofcourse
- then we initialize next_line to the return value of the function ft_readline and pass it the fd, the buffer and substrings[fd], this is where the magic happens!
- we don't need buffer anymore so we can free it, and set it to NULL
- now we need to put the remainder of 
READLINE
- 



	#include "get_next_line_bonus.h"

	static char	*read_line(int fd, char *buf, char *backup)
	{
		int		check;
		char	*temp;

		check = 1;
		while (check)
		{
			check = read(fd, buf, BUFFER_SIZE);
			if (check == -1)
				return (0);
			else if (check == 0)
				break ;
			buf[check] = '\0';
			if (!backup)
				backup = ft_strdup("");
			temp = backup;
			backup = (ft_strjoin(temp, buf));
			if (!backup)
				return (NULL);
			free (temp);
			temp = NULL;
			if (ft_strchr(buf, '\n'))
				break ;
		}
		return (backup);
	}

	static char	*extract(char *line)
	{
		int		i;
		char	*temp;

		i = 0;
		while (line[i] != '\0' && line[i] != '\n')
			i++;
		if (line[i] == '\0')
			return (NULL);
		temp = ft_substr(line, i + 1, ft_strlen(line) - i);
		if (!temp)
			return (NULL);
		if (temp[0] == '\0')
		{
			free (temp);
			temp = NULL;
			return (NULL);
		}
		line[i + 1] = '\0';
		return (temp);
	}

	char	*get_next_line(int fd)
	{
		char		*buf;
		char		*line;
		static char	*backup[OPEN_MAX];

		if (fd < 0 || BUFFER_SIZE <= 0 || fd > OPEN_MAX)
			return (NULL);
		buf = malloc(sizeof(char) * BUFFER_SIZE + 1);
		if (!buf)
			return (NULL);
		line = read_line(fd, buf, backup[fd]);
		free(buf);
		buf = NULL;
		if (!line)
			return (NULL);
		backup[fd] = extract(line);
		return (line);
	}




		int	main(void)
		{
			int fd1;
			int fd2;
			int fd3;

			fd1 = open("textfile.txt", O_RDONLY);
			fd2 = open("textfile2.txt", O_RDONLY);
			fd3 = open("textfile3.txt", O_RDONLY);

			printf("The fist 	line of the file 1 = %s\n", get_next_line(fd1));
			printf("The fist 	line of the file 2 = %s\n", get_next_line(fd2));
			printf("The fist 	line of the file 3 = %s\n", get_next_line(fd3));
			printf("The seccond line of the file 1 = %s\n", get_next_line(fd1));
			printf("The seccond line of the file 2 = %s\n", get_next_line(fd2));
			printf("The seccond line of the file 3 = %s\n", get_next_line(fd3));
			
			return (0);
		}

